{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":18042035815745641226,"abi":{"parameters":[{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"order_hash","type":{"kind":"field"},"visibility":"public"},{"name":"precomp_secret","type":{"kind":"field"},"visibility":"public"},{"name":"order_asset","type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]},"visibility":"public"},{"name":"nullifier","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"new_note_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"included_asset","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"input_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"output_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"inclusion_proof","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Merkle_proof","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"path","type":{"kind":"array","length":10,"type":{"kind":"field"}}}]}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"use dep::poseidon;\n\nstruct Combined_secret {\n    secret: Field,\n    nonce: Field,\n}\n\n// hash of note is H(asset_address, amount, H(secret,nonce))\n// a UTXO note private use only\nstruct Note {\n    asset_address: Field,\n    amount: u128,\n    secret: Combined_secret,\n}\n\nfn leaf_hasher(leafs: [Field; 2]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(leafs, 2)\n}\n\nfn process_path_hash(leaf: Field, index: u32, another_leaf: Field) -> Field {\n    // if index is even, then leaf is left child\n    // if index is odd, then leaf is right child\n    if index % 2 == 0 {\n        leaf_hasher([leaf, another_leaf])\n    } else {\n        leaf_hasher([another_leaf, leaf])\n    }\n}\n\nfn path_processor(leaf: Field, index: u32, hash_path: [Field; 10]) -> Field {\n    let mut calculated_hash = leaf;\n    let mut calculated_index = index;\n    for i in 0..10 {\n        calculated_hash = process_path_hash(calculated_hash, calculated_index, hash_path[i]);\n        calculated_index = calculated_index / 2;\n    }\n    calculated_hash\n}\n\n// H(asset_address, amount, H(secret,nonce))\nfn note_hasher(input: Note) -> Field {\n    let secret_hash =\n        poseidon::poseidon2::Poseidon2::hash([input.secret.secret, input.secret.nonce], 2);\n    poseidon::poseidon2::Poseidon2::hash(\n        [input.asset_address, input.amount as Field, secret_hash],\n        3,\n    )\n}\n\nstruct Merkle_proof {\n    index: u32,\n    path: [Field; 10],\n}\n\n// make order.\n// take in 2 notes\nfn main(\n    merkle_root: pub Field,\n    order_hash: pub Field,\n    precomp_secret: pub Field,\n    order_asset: pub Note,\n    nullifier: pub [Field; 2],\n    new_note_hash: pub [Field; 2],\n    included_asset: [Field; 2],\n    input_note: [Note; 2],\n    output_note: [Note; 2],\n    inclusion_proof: [Merkle_proof; 2],\n) {\n    // check if all input are valid\n    for i in 0..2 {\n        // skip if input note is empty\n        if input_note[i].amount != 0 {\n            // check correct nullifier\n            assert(nullifier[i] == input_note[i].secret.nonce);\n            // note is valid in tree\n            let leaf = note_hasher(input_note[i]);\n            let processed_root =\n                path_processor(leaf, inclusion_proof[i].index, inclusion_proof[i].path);\n            assert(processed_root == merkle_root);\n            // assert note asset is in included_asset in any order\n            assert(\n                (input_note[i].asset_address == included_asset[0])\n                    | (input_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    let mut sum_asset_1_in = 0;\n    let mut sum_asset_2_in = 0;\n    for i in 0..2 {\n        if input_note[i].asset_address == included_asset[0] {\n            sum_asset_1_in += input_note[i].amount;\n        } else {\n            sum_asset_2_in += input_note[i].amount;\n        }\n    }\n\n    // check if output notes are valid\n    for i in 0..2 {\n        if output_note[i].amount != 0 {\n            // note hash correctly\n            let out_hash = note_hasher(output_note[i]);\n            println(out_hash);\n            println(new_note_hash[i]);\n\n            assert(new_note_hash[i] == out_hash);\n            // asset is in included_asset in any order\n            assert(\n                (output_note[i].asset_address == included_asset[0])\n                    | (output_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    // sum of output\n    let mut sum_asset_1_out = 0;\n    let mut sum_asset_2_out = 0;\n    for i in 0..2 {\n        if output_note[i].asset_address == included_asset[0] {\n            sum_asset_1_out += output_note[i].amount;\n        } else {\n            sum_asset_2_out += output_note[i].amount;\n        }\n    }\n\n    // sum order asset\n    if order_asset.amount != 0 {\n        // asset is in included_asset in any order\n        assert(\n            (order_asset.asset_address == included_asset[0])\n                | (order_asset.asset_address == included_asset[1]),\n        );\n        if order_asset.asset_address == included_asset[0] {\n            sum_asset_1_out += order_asset.amount;\n        } else {\n            sum_asset_2_out += order_asset.amount;\n        }\n    }\n\n    // assert in and out\n    assert(sum_asset_1_in == sum_asset_1_out);\n    assert(sum_asset_2_in == sum_asset_2_out);\n}\n\nfn fake_merkle_proof(input: [Field; 2]) -> ([Merkle_proof; 2], Field) {\n    let mut current = leaf_hasher([input[0], input[1]]);\n    let mut p1 = [0; 10];\n    let mut p2 = [0; 10];\n    p1[0] = input[1];\n    p2[0] = input[0];\n\n    for i in 1..10 {\n        let random = poseidon::poseidon2::Poseidon2::hash([i as Field], 1);\n        current = leaf_hasher([current, random]);\n        p1[i] = random;\n        p2[i] = random;\n    }\n\n    let first_proof = Merkle_proof { index: 0, path: p1 };\n    let second_proof = Merkle_proof { index: 1, path: p2 };\n\n    ([first_proof, second_proof], current)\n}\n\n#[test]\nfn test_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p1.index, p1.path);\n    assert(root == root1);\n\n    let root2 = path_processor(test2, p2.index, p2.path);\n    assert(root2 == root);\n}\n\n#[test]\nfn test_failed_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p2.index, p1.path);\n    assert(root != root1);\n\n    let root2 = path_processor(test2, p1.index, p2.path);\n    assert(root2 != root);\n\n    let root3 = path_processor(test1, p1.index, p2.path);\n    assert(root != root3);\n\n    let root4 = path_processor(test1, p2.index, p1.path);\n    assert(root != root4);\n}\n\n#[test]\nfn test_simple_note_hash() {\n    let note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let hash = note_hasher(note);\n    assert(\n        hash\n            == poseidon::poseidon2::Poseidon2::hash(\n                [1, 100, poseidon::poseidon2::Poseidon2::hash([42, 69], 2)],\n                3,\n            ),\n    );\n}\n\n#[test]\nfn test_note_in_main() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    main(\n        merkle_root,\n        0,\n        0,\n        order_note,\n        [69, 0],\n        [note_hash, note_hash],\n        included_asset,\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test]\nfn test_note_full() {\n    let test_note_1 =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let test_note_2 =\n        Note { asset_address: 2, amount: 50, secret: Combined_secret { secret: 123, nonce: 456 } };\n    let included_asset = [1, 2];\n\n    let test_note_1_hash = note_hasher(test_note_1);\n    let test_note_2_hash = note_hasher(test_note_2);\n\n    let new_note_1 =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 2, nonce: 3 } };\n\n    let new_note_2 =\n        Note { asset_address: 2, amount: 35, secret: Combined_secret { secret: 12, nonce: 31 } };\n\n    let new_note_hash_1 = note_hasher(new_note_1);\n    let new_note_hash_2 = note_hasher(new_note_2);\n\n    let tmp = fake_merkle_proof([test_note_1_hash, test_note_2_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n\n    let order_note_1 =\n        Note { asset_address: 2, amount: 15, secret: Combined_secret { secret: 0, nonce: 0 } };\n\n    main(\n        merkle_root,\n        0,\n        0,\n        order_note_1,\n        [69, 456],\n        [new_note_hash_1, new_note_hash_2],\n        included_asset,\n        [test_note_1, test_note_2],\n        [new_note_1, new_note_2],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_sum() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 50, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        merkle_root,\n        0,\n        0,\n        order_note,\n        [69, 0],\n        [note_hash, note_hash],\n        included_asset,\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_wrong_asset() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [3, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        merkle_root,\n        0,\n        0,\n        order_note,\n        [69, 0],\n        [note_hash, note_hash],\n        included_asset,\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n","path":"/Users/yoyoismacbook/Desktop/zinch/zeroinch/circuit/src/main.nr"},"68":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/yoyoismacbook/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["print_unconstrained","directive_invert","directive_integer_quotient"]}