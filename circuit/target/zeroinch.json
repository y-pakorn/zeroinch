{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":16471812594402794493,"abi":{"parameters":[{"name":"included_asset","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"order_hash","type":{"kind":"field"},"visibility":"public"},{"name":"precomp_secret","type":{"kind":"field"},"visibility":"public"},{"name":"order_asset","type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]},"visibility":"public"},{"name":"nullifier","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"new_note_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"input_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"output_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"inclusion_proof","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Merkle_proof","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"path","type":{"kind":"array","length":10,"type":{"kind":"field"}}}]}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dB5RW1bXed2YoM0OTFkEBe6HIf6fAIKiDJYlKETRdygwlMVG6psuAoOlSBE3VIM2WWEDFFLFQRFPEgoixi2WCBWPeezF57+0t98iZM3cmd/l/+657wpy19rp3zp3Z/z77fPuc7zt3GALa1wYUEG0O9t3LpTC6tmarc/o6xPR1junrHtPXM6avF9thTt9xUV9R9HUUWoNm+qqjay6/FnbA+crZ8ZZrBlyu4LfC8lWeG1RRMWVw2ZSwPKzJlQ2prarMVVTWDqoKq8LKqsrJZVXl5VOqKqoGD6kdMjg3JKwonxJOrRxSPjVypjXuCivBIL8fxFrg+Mx3/MVRrKixd4r8FYBzWgwccyfwnDRVP/nGWelJnIM+epxlbodZrIusWDuy/W9038m6r7TuB0X35ucGs1WxDWE70erXysHQj56D8iQ5aG+NtYN1P9i6H+rkYBjbSWwns50S9YsV0P76bC4nufxa2It08EvYOMsKYnwONwkxO7486OP0DafGO3+hYhI/KkinTN3XqgkH+OG4MebSZFHIuO14T9UM+FQFv6cBwaA17tOsBIP8xq6uslKaVbQ3JdthTmc7g+3jbJ+g/VLA9W37G5bQ9yfZzmQ7i+1sxx8B560iyjGarSGxNYKwu4iGGpHxFirMDcoXcj5GAnPXwkYatQZsZFR0HW0SYpiHPHDZyGjyi42MIhwoRxOWjaQFylHkHyjPia5jyAGgPHBBOYb0QYkAkgHlOYQD5RjCgjItioyM2453rGbAYxX8ngsEg9a4z7USDPIbe9CYy6+FQpeBVC4UijyS8JT4PMKC35UD4t/Q/j6UTA58iu3TbJ9h+yw1LTVsf+cl9P05ts+zfYHtfNKVGucq4ApZo+MIW0MaUkPGm2WpgZyP8cDctbC6Rq0Bq5sQXSeahBgGJw9cVjeR/GJ1EwgHyomEZXVpgXIC+QfKmuhaSw4A5YELylrSByUCSAaUNYQDZS1hQZmW1EDGbcc7STPgSQp+JwPBoDXuyVaCQX5VpIbQZSCVC4Uijyc8JZ5CWPC7ckD8G9p/GCWTA1PZvsj2JbYLqGmpYfubktD3l9m+wnYh20WkKzUmK+AKWaPTCFtDGlJDxptlqYGcj+nA3LWwukatAaubEV1nmoQYBicPXFY3k/xidTMIB8qZhGV1aYFyBvkHylnRdTY5AJQHLihnkz4oEUAyoJxFOFDOJiwo05IayLjteOdoBjxHwe/FQDBojftiK8EgvypSQ+gykMqFQpGnE54SX0JY8LtyQPwb2n84JZMDX2X7GtvX2b5BTUsN298lCX1/k+1bbN9mu5R0pcbFCrhC1uhcwtaQhtSQ8WZZaiDnow6YuxZW16g1YHXzout8kxDD4OSBy+rmk1+sbh7hQDmfsKwuLVDOI/9AeVl0XUAOAOWBC8oFpA9KBJAMKC8jHCgXEBaUaUkNZNx2vAs1A16o4PdyIBi0xn25lWCQXxWpIXQZSOVCoch1hKfEVxAW/K4cEP+G9h9ByeTAd9i+y/Y9tu9T01LD9ndFQt8/YPsh24/YriRdqXG5Aq6QNbqIsDWkITVkvFmWGsj5WAzMXQura9QasLol0XWpSYhhcPLAZXVLyS9Wt4RwoFxKWFaXFiiXkH+gvCq6LiMHgPLABeUy0gclAkgGlFcRDpTLCAvKtKQGMm473uWaAS9X8Hs1EAxa477aSjDIr4rUELoMpHKhUOTFhKfE1xAW/K4cEP+G9h9JyeTAj9l+wvZTtp9R01LD9ndNQt8/Z/sF27Vs15Gu1LhaAVfIGv0lYWtIQ2rIeLMsNZDzsQKYuxZW16g1YHXXR9eVJiGGwckDl9WtJL9Y3fWEA+VKwrK6tEB5PfkHylXRdTU5AJQHLihXkz4oEUAyoFxFOFCuJiwo05IayLjteNdoBrxGwe9aIBi0xr3WSjDIr4rUELoMpHKhUOQVhKfENxAW/K4cEP+G9h9FyeTAjWw3sd3Mdgs1LTVsfzck9P0rtl+z3cp2G+lKjbUKuELW6O2ErSENqSHjzbLUQM7HHcDctbC6Rq0Bq1sXXdebhBgGJw9cVree/GJ16wgHyvWEZXVpgXId+QfKO6PrXeQAUB64oLyL9EGJAJIB5Z2EA+VdhAVlWlIDGbcd792aAd+t4HcDEAxa495gJRjkV0VqCF0GUrlQKPIdhKfE9xAW/K4cEP+G9h9NyeTAb9h+y/Y7tt9T01LD9ndPQt/3sm1ku4/tftKVGhsUcIWs0QcIW0MaUkPGm2WpgZyPB4G5a2F1jVoDVrcpum42CTEMTh64rG4z+cXqNhEOlJsJy+rSAuUm8g+UW6LrVnIAKA9cUG4lfVAigGRAuYVwoNxKWFCmJTWQcdvxPqQZ8EMKfrcBwaA17m1WgkF+VaSG0GUglQuFIj9IeEr8MGHB78oB8W9o/zGUTA48wvYHtj+y/Ymalhq2v4cT+v4z26Ns29keI12psU0BV8gafZywNaQhNWS8WZYayPl4Api7FlbXqDVgdU9G1x0mIYbByQOX1e0gv1jdk4QD5Q7Csrq0QPkk+QfKp6LrTnIAKA9cUO4kfVAigGRA+RThQLmTsKBMS2og47bjfVoz4KcV/O4CgkFr3LusBIP8qkgNoctAKhcKRX6C8JT4GcKC35UD4t/Q/mMpmRz4C9uzbM+xPU9NSw3b3zMJfb/A9iLbS2wvk67U2KWAK2SNvkLYGtKQGjLeLEsN5HzsBuaOFLAndQnETCi1uFuh9l4lLK5NK8gwDl9Txk6+8Yk/ZIyvRv4Ii/EG841ed4Bxhu2Bcb0OzF+axB0Ztx3vG5oBv6Hgtx4MUo1x11sJBvlVLdaAslmsfyU/ixUZtx3vHs2A9yj4fZOyXawy7jetBIP8xsaa7/jro1jRR2z1GZ3vt5TnI5dfC4WRvaUwz0DmmOqi15l0Fr23NQN+W8HvO5TtRU/G/Y6VYJDf2KPFfMdfEsWKGnvXyB/6uKAEOOauhC0k9yixC+0/MuxKyY4S97K9y/Y3tveo6WPKgywfna37vdb9UMf339n+i+2/2f4n6k/zRd1xhK0Bt4F8N3hR94/o+r5JiHkpJw/cF3Xvk/6LOjuJ+b6o+wfhiul98nM3RcZtx/tPzYD/qeD3X5Tt3VTG/S8rwSC/sSu3rJRmFT2ekq3ccv9/kYMgaHrltv39PaHvAu4sFJ9srQK9F0zvRDlG79pIbLUOsi1XTA7RZ0dItoucjza4+Qhb2Eij1oCNtI2SUGx2R8M85IHLRuSbfGIjbQMcKIsDLBtJC5RtA/9AWRIlodQFZUkMKEtTACUCSAaUJUBQloJBmRZFRsZtx9suUAy4XYD32x4IBq1xt7cyDPKr8rtsQm+BVC4UitwmwFPiDmDwu3JA/Bva35eSyYGO3NmJ7SC2zs1IDduf/TnN+e7CnV3ZurF1D3SlhmAVjStkjX7MA6kh482y1EDOx8GeSg0fWV2PKAk9XVbXI4bV9fSM1fUAgrKnp1Kjh4egPCRKwqEuKA+JAeWhKYCyBxCUhwBBeainUgMZtx1vr0Ax4F4KUqN3xqWGjLu3J1JD6DKQyoVCkQ9WkBp9lKVGH0sC9KNkcuAw7jyc7Qi2I5uRGra/PgmlxlHceTTbMWzHBrpSo7eC1EDW6HEeSI3eGZcayPk43lOp4SOr6xsloZ/L6vrGsLp+nrG6vkBQ9vNUavT1EJT9oyQMcEHZPwaUA1IAZV8gKPsDQTnAU6mBjNuO94RAMeATFKTGwIxLDRn3QE+khtBlIJULhSIfryA1cspSI2dJgP6UTA6E3FnGVs5W0YzUsP3lEkqNSu4cxDaYrSrQlRoDFaQGskaHeCA1BmZcaiDn40RPpYaPrG5olIRhLqsbGsPqhnnG6oYCQTnMU6kx1ENQnhQl4WQXlCfFgPLkFEA5FAjKk4CgPNlTqYGM2473lEAx4FMUpEZ1xqXGBxPlidQQugykcqFQ5BMVpMZwZakx3JIAAyiZHDiVO09jO53tjGakhu1veEKp8XHu/ATbJ9nODHSlRrWC1EDW6FkeSI3qjEsN5Hyc7anU8JHVjYiSMNJldSNiWN1Iz1jdCCAoR3oqNUZ4CMpRURJGu6AcFQPK0SmAcgQQlKOAoBztqdRAxm3He06gGPA5ClJjTMalhox7jCdSQ+gykMqFQpHPVpAaY5WlxlhLApxAyeTAudx5Htun2D7djNSw/Y1NKDU+w52fZfsc2+cDXakxRkFqIGv0Cx5IjTEZlxrI+TjfU6nhI6sbFyVhvMvqxsWwuvGesbpxQFCO91RqjPMQlBOiJEx0QTkhBpQTUwDlOCAoJwBBOdFTqYGM2463JlAMuEZBatRmXGrIuGs9kRpCl4FULhSKfL6C1JikLDUmWRJgICWTA5O5cwrbVLYvNiM1bH+TEkqNL3HnBWxfZvtKoCs1ahWkBrJGL/RAatRmXGog5+MiT6WGj6xuWpSE6S6rmxbD6qZ7xuqmAUE53VOpMc1DUM6IkjDTBeWMGFDOTAGU04CgnAEE5UxPpQYybjveWYFiwLMUpMbsjEsNGfdsT6SG0GUglQuFIl+kIDXmKEuNOZYEkEQnkQMXc+clbF9l+1ozUsP2Nyeh1Pg6d36D7Zts3wp0pcZsBamBrNFveyA1ZmdcaiDn41JPpYaPrG5ulIQ6l9XNjWF1dZ6xurlAUNZ5KjXmegjKeVES5rugnBcDyvkpgHIuEJTzgKCc76nUQMZtx3tZoBjwZQpSY0HGpYaMe4EnUkPoMpDKhUKRL1WQGguVpcZCSwLI/wicRA5czp1XsH2H7bvNSA3b38KEUuN73Pl9th+w/TDQlRoLFKQGskZ/5IHUWJBxqYGcjys9lRo+srpFURIWu6xuUQyrW+wZq1sEBOViT6XGIg9BuSRKwlIXlEtiQLk0BVAuAoJyCRCUSz2VGsi47XivChQDvkpBaizLuNSQcS/zRGoIXQZSuVAo8pUKUmO5stRYbkmAMkomB67mzmvYfsz2k2akhu1veUKp8VPu/Bnbz9l+EehKjWUKUgNZo9d6IDWWZVxqIOfjOuB6IT7Q2JO6BGImlFq8TmFN+6USyyzIMA5XKGMn3/jEHzJGmeMVSlzANPS6g6zFg4BxXe8pcUfGbce7MlAMeKUCcV+VceIu417lWbEGlM1iXe1psa5WKtY1gWLAaxSKdW3Gi1XGvVapWNFMb1UUK/qIbVWQzfm+IeOKTRjZDQqMfkXQwvDyietGTzeNG5U2jZsCxYBvUtg0bs74piHjvjmlTSOXXws7sI96wh+PdCbcHN2S8YVe5voWhYX+V+CCN+/lxG8dNWzoIw5kjf4afJyjVUPo+b9VGfd5/zfk0bjRhLMDZXMdui3j65DUyW0K69DtSuvQ7dY6pIVN9L7WARjjHZ4S0e6ExYNp6wLFgNcpENH1GSeiMu71CkQ07v3zx2j/e+aDKdn75zu58y62u9k2BE2/2+5m+ehu3cvPm/uhju97uPM3bL9l+13k2zwroKZbNSj3tk/0vN6jcAIQNBVsvsBeD2Rv/ykTWEoH6ATak4eKT5KJjFF8SYWhqUMpcMwaK4C0LJ8BdgPG9XtPqRcybjveewPFgO9VoF4bM069ZNwblc4ATcvyW15ksd7nabHep1Ss9weKAd+vUKwPZLxYZdwPpHRgn+/4N0axog/dNgbZnO8HlZgOmoUizwI2ZfzAW+Zkk8JB4yZPF/qepLPQbw4UA96ssNBvyfhCL+PektKB2CG0/3DqUEp2ILaVOx9i28b2cDMHYj0sHz2t+63NHIg9wp1/YPsj25/+ww7EHvHpQGxLy4FYI9/t6ACdQHvyUPFJMpExiq9HFA7E2gHHrLECSMvygVgPYFx/9pR6IeO24300UAz4UQXqtT3j1EvGvf0APhBDFutjnhbrY0rF+nigGPDjCsX6RMaLVcb9hCcHYtujWNEHYtuDbM73k54ciCHPAnZk/EBM5mSHwoHYjsCPjRKZS+RG+ZSnG+VTShvlzkAx4J0KG+XTGd8oZdxPp7RR5vJrH/w24EYFGW+ffuc7R7uCbOdQ5nqXwkL/DLjgza9Yi986atjQGz2yRv+S8Y3e1BB6/p9Vxn2+8Zlxo0k28FfJoevQcxlfh6ROnlPA4fNK69Dzgd4/9dDa17oDY3zBUyLamrB4MO3FQDHgFxWI6EsZJ6Iy7pc8O15Fjr8VMK6XPS3WlwOdYn0lUAz4FYVi3Z3xYpVx7z6A34Ugi/VVT4v1VaVifS1QDPg1hWJ9PePFKuN+3ZN3IbujWNEybXeQzfl+Q+l8HH1EgmSP9Rk/IpE5qVeQpvWBbu3l8mtqR4N9C7J/FPGswrj7FejUdhF4/K2BY/4rsLaBuAn7ZRyDu5XWnD0ZX3MEL3sUxv2m0jHgmym8jtgD3GvfAu+1pqHF2dst68ZHik/27BcU6qe/B3u2xuuDAQfgnv0OsPaAuAkHKGMQoVXrFV7b1APX/70Z3/8Fe3sV6vhdpf3/3RT2/73A+f+bJ/v/ewfIGoTeB8xfbkX5k7/AeCsQf4bfo/wJn31b6SxTY27uAM/NbQF230evNe8pzE1gzc0x0bU9m/wly45sndjkz6vLvzHuwtaV9v3BPfn1B/mjfvLH/OR3cuXXa+TfNMu/Ze7F1pv2/Y+fh7EdznYE25FsR7EdHX3WsWzHsR3P1petH1t/tgFsJ7ANlPHRvv8nuyyKyzSJW/aGwih+eWkkvK0NW1u2YrYSNvmzWu2sn2tt3V8Y5bPby8N7zNy25gzrEc1s5tm1zTxb2cyzDc08u6+JZ2YvOCu6FkdXsy+a/bM6+jqXXwuLLb9o/1W5ikHF1LCB4y8vtnwq+C8z/ot0/OfaRH5Or2von5zPLXS+z/0Zae2p8QtL8z3mWYH17IzomdRPB9p/3zG6L3b8aWDDjgmd2y4x8ZvPKo3GerozVjv3ASyWQZPicITzX15j/LfSiX+I8d9axf/gWuO/jY7/ycZ/W538fIjlYh3/U4z/EhX/ZR+uc6U68Vca/+10/FcY/+11/Nea9dOsk+YziPavHR2tftw6FoaB83lEDdcpcj6/xIkVzRkC5/NMPG5+zFprctcpJtZOMc/cNaZTzOd0ivmcOF8lQF/tgb7cdTofX8VAX+2AvpC5L8poXG2BvpCYKAX6KgT6yiq+DO+I44HSqqNrLs9mYi2KiTVu7ZR8GVzMmHXBtDnkNNtRYAVsvi5wnhVZSbC/r7AJf/Rv/AcxvqQJAM3CVFTX8HOqo/5cHm1w1f7fdCyM/Lei/eOwW5H13P7+M6OvbSCZa1EecU4dXBNOLa+ZWlNZM3lyxaSazo5/aQUxeTLXboTPV84S+111/H8oZu3Wzbrv6ozTFqPVoBiMP4ODVtS4FTjPzPe2deIL8PGFbiyFMZ9lWpfo2tXq69ZErDaG0Qcg0kp1/MdipsS6L3Wembkrivm5oImvC5xrc98bNOO3fcwz49PMlR2vGcf/A2EVR2g4igEA","debug_symbols":"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","file_map":{"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"use dep::poseidon;\n\nstruct Combined_secret {\n    secret: Field,\n    nonce: Field,\n}\n\n// hash of note is H(asset_address, amount, H(secret,nonce))\n// a UTXO note private use only\nstruct Note {\n    asset_address: Field,\n    amount: u128,\n    secret: Combined_secret,\n}\n\nfn leaf_hasher(leafs: [Field; 2]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(leafs, 2)\n}\n\nfn process_path_hash(leaf: Field, index: u32, another_leaf: Field) -> Field {\n    // if index is even, then leaf is left child\n    // if index is odd, then leaf is right child\n    if index % 2 == 0 {\n        leaf_hasher([leaf, another_leaf])\n    } else {\n        leaf_hasher([another_leaf, leaf])\n    }\n}\n\nfn path_processor(leaf: Field, index: u32, hash_path: [Field; 10]) -> Field {\n    let mut calculated_hash = leaf;\n    let mut calculated_index = index;\n    for i in 0..10 {\n        calculated_hash = process_path_hash(calculated_hash, calculated_index, hash_path[i]);\n        calculated_index = calculated_index / 2;\n    }\n    calculated_hash\n}\n\n// H(asset_address, amount, H(secret,nonce))\nfn note_hasher(input: Note) -> Field {\n    let secret_hash =\n        poseidon::poseidon2::Poseidon2::hash([input.secret.secret, input.secret.nonce], 2);\n    poseidon::poseidon2::Poseidon2::hash(\n        [input.asset_address, input.amount as Field, secret_hash],\n        3,\n    )\n}\n\nstruct Merkle_proof {\n    index: u32,\n    path: [Field; 10],\n}\n\n// make order.\n// take in 2 notes\nfn main(\n    included_asset: pub [Field; 2],\n    merkle_root: pub Field,\n    order_hash: pub Field,\n    precomp_secret: pub Field,\n    order_asset: pub Note,\n    nullifier: pub [Field; 2],\n    new_note_hash: pub [Field; 2],\n    input_note: [Note; 2],\n    output_note: [Note; 2],\n    inclusion_proof: [Merkle_proof; 2],\n) {\n    // check if all input are valid\n    for i in 0..2 {\n        // skip if input note is empty\n        if input_note[i].amount != 0 {\n            // check correct nullifier\n            assert(nullifier[i] == input_note[i].secret.nonce);\n            // note is valid in tree\n            let leaf = note_hasher(input_note[i]);\n            let processed_root =\n                path_processor(leaf, inclusion_proof[i].index, inclusion_proof[i].path);\n            assert(processed_root == merkle_root);\n            // assert note asset is in included_asset in any order\n            assert(\n                (input_note[i].asset_address == included_asset[0])\n                    | (input_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    let mut sum_asset_1_in = 0;\n    let mut sum_asset_2_in = 0;\n    for i in 0..2 {\n        if input_note[i].asset_address == included_asset[0] {\n            sum_asset_1_in += input_note[i].amount;\n        } else {\n            sum_asset_2_in += input_note[i].amount;\n        }\n    }\n\n    // check if output notes are valid\n    for i in 0..2 {\n        if output_note[i].amount != 0 {\n            // note hash correctly\n            let out_hash = note_hasher(output_note[i]);\n            println(out_hash);\n            println(new_note_hash[i]);\n\n            assert(new_note_hash[i] == out_hash);\n            // asset is in included_asset in any order\n            assert(\n                (output_note[i].asset_address == included_asset[0])\n                    | (output_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    // sum of output\n    let mut sum_asset_1_out = 0;\n    let mut sum_asset_2_out = 0;\n    for i in 0..2 {\n        if output_note[i].asset_address == included_asset[0] {\n            sum_asset_1_out += output_note[i].amount;\n        } else {\n            sum_asset_2_out += output_note[i].amount;\n        }\n    }\n\n    // sum order asset\n    if order_asset.amount != 0 {\n        // asset is in included_asset in any order\n        assert(\n            (order_asset.asset_address == included_asset[0])\n                | (order_asset.asset_address == included_asset[1]),\n        );\n        if order_asset.asset_address == included_asset[0] {\n            sum_asset_1_out += order_asset.amount;\n        } else {\n            sum_asset_2_out += order_asset.amount;\n        }\n    }\n\n    // assert in and out\n    assert(sum_asset_1_in == sum_asset_1_out);\n    assert(sum_asset_2_in == sum_asset_2_out);\n}\n\nfn fake_merkle_proof(input: [Field; 2]) -> ([Merkle_proof; 2], Field) {\n    let mut current = leaf_hasher([input[0], input[1]]);\n    let mut p1 = [0; 10];\n    let mut p2 = [0; 10];\n    p1[0] = input[1];\n    p2[0] = input[0];\n\n    for i in 1..10 {\n        let random = poseidon::poseidon2::Poseidon2::hash([i as Field], 1);\n        current = leaf_hasher([current, random]);\n        p1[i] = random;\n        p2[i] = random;\n    }\n\n    let first_proof = Merkle_proof { index: 0, path: p1 };\n    let second_proof = Merkle_proof { index: 1, path: p2 };\n\n    ([first_proof, second_proof], current)\n}\n\n#[test]\nfn test_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p1.index, p1.path);\n    assert(root == root1);\n\n    let root2 = path_processor(test2, p2.index, p2.path);\n    assert(root2 == root);\n}\n\n#[test]\nfn test_failed_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p2.index, p1.path);\n    assert(root != root1);\n\n    let root2 = path_processor(test2, p1.index, p2.path);\n    assert(root2 != root);\n\n    let root3 = path_processor(test1, p1.index, p2.path);\n    assert(root != root3);\n\n    let root4 = path_processor(test1, p2.index, p1.path);\n    assert(root != root4);\n}\n\n#[test]\nfn test_simple_note_hash() {\n    let note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let hash = note_hasher(note);\n    assert(\n        hash\n            == poseidon::poseidon2::Poseidon2::hash(\n                [1, 100, poseidon::poseidon2::Poseidon2::hash([42, 69], 2)],\n                3,\n            ),\n    );\n}\n\n#[test]\nfn test_note_in_main() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    main(\n        included_asset,\n        merkle_root,\n        0,\n        0,\n        order_note,\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test]\nfn test_note_full() {\n    let test_note_1 =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let test_note_2 =\n        Note { asset_address: 2, amount: 50, secret: Combined_secret { secret: 123, nonce: 456 } };\n    let included_asset = [1, 2];\n\n    let test_note_1_hash = note_hasher(test_note_1);\n    let test_note_2_hash = note_hasher(test_note_2);\n\n    let new_note_1 =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 2, nonce: 3 } };\n\n    let new_note_2 =\n        Note { asset_address: 2, amount: 35, secret: Combined_secret { secret: 12, nonce: 31 } };\n\n    let new_note_hash_1 = note_hasher(new_note_1);\n    let new_note_hash_2 = note_hasher(new_note_2);\n\n    let tmp = fake_merkle_proof([test_note_1_hash, test_note_2_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n\n    let order_note_1 =\n        Note { asset_address: 2, amount: 15, secret: Combined_secret { secret: 0, nonce: 0 } };\n\n    main(\n        included_asset,\n        merkle_root,\n        0,\n        0,\n        order_note_1,\n        [69, 456],\n        [new_note_hash_1, new_note_hash_2],\n        [test_note_1, test_note_2],\n        [new_note_1, new_note_2],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_sum() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 50, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        included_asset,\n        merkle_root,\n        0,\n        0,\n        order_note,\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_wrong_asset() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [3, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        included_asset,\n        merkle_root,\n        0,\n        0,\n        order_note,\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n","path":"/Users/yoyoismacbook/Desktop/zinch/zeroinch/circuit/src/main.nr"},"68":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/yoyoismacbook/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["print_unconstrained","directive_invert","directive_integer_quotient"]}