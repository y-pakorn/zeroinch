{"noir_version":"1.0.0-beta.8+ba05d729b9753aa5ce2b076c1dd4795edb173f68","hash":"4167611046055185006","abi":{"parameters":[{"name":"included_asset","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"order_hash","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"precomp_secret","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"public"},{"name":"order_asset","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"public"},{"name":"nullifier","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"new_note_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"input_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"output_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"inclusion_proof","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Merkle_proof","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"path","type":{"kind":"array","length":10,"type":{"kind":"field"}}}]}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"pZrNbtxIEoTfRWcfWBn1O6+yWBiyLQ8ECLIhWwMsjHn3ZbLyY9uHbjTIiyusVieDxYz8yG79evjy9On974/Pr1+//Xj46z+/Hj69Pb+8PP/98eXb58efz99e15/++vfDA//9+PPt6Wn90cNvr6/v+v749vT68+Gv1/eXlw8P/zy+vG+/9OP74+u2/nx8W19dPjw8vX5Z17Xg1+eXJ1f/fri8e7n+Viu5xbut1LwXKPdXqMbxraodqbBcKizS2Qq5HKmQlkqFlPqhCmZ7BZ32kA95MBMVTPVQhZQuFa5ezXG9wuhcivV07FqBdMODChuZ02/n0P4skG6cREv7RjYtV0vY9RKpNXYytWFXS+jGRuQSFUbpRwqkZe+odSvLodMYy6DEsKunceNypiT2MqVypCFW732v0MfVjuhnO2Kc7ghbTneEpZMdcavAnR1x8zTu64hbI0J7BZMdGvhS2SuUQwPfer9UuNpT1q6XuFzO1suhAjtzWr86au1GU2pwDnlpJwskO1Ig77jI5eop6NZ8qeVCzasFdDLZyqeT7Q13Mtk+B08l+1aBO5N98zTuS/bNfmg0VLl+OfNysh9yOtkP2U73Q9bpfsj5ZD/cKnBnP9w8jTv74caI64nT6MfuaLXfDFpexpEK5XI5Dz6flD5OPp+UfRvWCofuy7t2XPV26L68l30fej20k8P2sxjHzmIs+7PiOPSUpcVH+VZBy6EnnD8q1OVIhSTOQqmkQxX2nVwrXAVvXc4+JNWzg7KeH5T1/KCsZwdlPT8o6/lBeet63vmUdLPEfY9JdZzsibac7omWTvdEs5M9cavAnT1x8zROPyYp7RuhG9fzzgq2HJpUNrie0rGJrcakUk7jmId9WmY7NLFr3md+7flQhbrvZG1H7gHULtxpx8jV9rsItXLoWnRjQqhnO1uhHNrJkcmFRtXZCuPITubl8ti6NDvm4bdH7yNnkdNS9ll7aCfzJd15/cD4SAW7zHsbR/Yhq/Jpb1735EiFvOw7mfOfM+q/6/8ePz+//fGdx0Nff/PDw9j+Tctc0jqM18XWYbvualKsOdbiTxLrWmNtfvO3rj3WMVdbYk0+O9fVYlWs2dt+Xdd6eZ2LVudnE9ZidWv++pirllhTrBarYs2xlnlc1VjDn8Kfxjx+XmINf9mmn6xY8/SVy/STw19u8zg5/OXwV8JfCX8l/JXwV/I8fgl/JfyV8Ff69FHCXw1/NU0/NfxVTV81Tz81/NU6j1PDXw1/Nfy18NfCXwt/TfP4Lfy18NfCX2vTRwt/Lfz1Zfrp4a/b9NU1/fTw18s8Tg9/Pfz18NfD3wh/I/wNm8cf4W+EvxH+Rp0+Rvgb4W+M6SctCyJNZ+uNyLSUFiGiadb5gaiIhuiIcJrSgkjR88kQQmREmb5SqoiG6OEw4dlDs1ndUuMODc8WfZQMz4Znw7PhmfAk0pMUcUzCs/AsPHuENmPCs/C8pWirg2fP0WZ1C5I7zHjO0Vop4znjOeM545k8JQKVckyQVPBc8FzwXGKKpILnguctWF6n4NmjtVndsrXNLjzX6LZU8VzxXPFc8UzEEhlLlaFX8dzw3PDcYvClhueG5y1rXqfh2dO2Wd3ito1XPHe6ruO547njueOZ1KVeGc/7nMZzx/OIUZNGQuB5xDRMIyNiXqcRAzGNhvB9Hi7GFOYZnCI5hVwYQoiMKP5Jp4uKaIiOWCs7Z80zOEXaqGUewW1VrHnDmHn+nFsGsAxiGciynVk7tC7UAls7t3Zw7eTa0bWza4cX+TPwZfDLAJhBMANhBsMMiBkUMzBmcMwAmUEyA2UGywyYGTQzcGbkz8ifQTQDaQbTDKgZVDOwZnDNAJtBNgNtBtsMuBl0M/Bm8M0AnEE4I39G/gzIGZQzMGdwzgCdQToDdQbrDNgZtDNwZ/DOAJ5BPAN5BvMM6Bn5M7BncM8An0E+A30G+wz4GfQz8GfwzwCgQUADgQYDBQMFAwUDBQMFAwUDBQMFAwUDBQOV9tuxmHOCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgSKD2u8gYaBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKDyfn+KZxgoGCgyKDIoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKDIoMigYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoGCgYKBgoMigYqL4/C+AZBgoGCgYKBgoGCgYKBgoGCgYKBgoGZhiYYWCGgRkGZhiYYWCGgRkGZhiYYWCGgdkzWPzZxDM4hRAZURBe2R9sPINTdMQI4Rks3UVCGGKtXLffccBmF8W/v3dR/dt3Fw3RESOEZ7D5bngGpzCEEGtl/0g+ewanqIgWNjyDU4wQnsHNmGdwM+YZ3Ix5BrejewanKAg8ewa3o3sGpxghCp49g5sNz+AUQrhnvzqewSkqoiE6Yq3c3aFncIqEMIRX9tPxDE5REF7ZPXsGp+iIEcIz6F+1Zc/gFIYQYq083LxncIqKWCsPby3P4BQjhGdwioQwhBAZ4ZW96zyDUzRER4wQnsEpEsIQ7MZgNwa7MdiNwW4MdmPEbpQldqMsCWEIIWI3ylIQFRG7UZaOiN0oaUEkhCGEyIjYjZIqoiE6Inaj2IJICEN45ezCK/unl/88vj0/fnp5+vGw/SHr1/fXz7/9XevP/33nFf7y9fvbt89PX97fnvzzoO219ROi/wM=","file_map":{"50":{"source":"use dep::poseidon;\nuse trees::merkle::MerkleTree;\n\nstruct Combined_secret {\n    secret: Field,\n    nonce: Field,\n}\n\nfn leaf_hasher(leafs: [Field; 2]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(leafs, 2)\n}\n\nfn process_path_hash(leaf: Field, index: u32, another_leaf: Field) -> Field {\n    // if index is even, then leaf is left child\n    // if index is odd, then leaf is right child\n    if index % 2 == 0 {\n        leaf_hasher([leaf, another_leaf])\n    } else {\n        leaf_hasher([another_leaf, leaf])\n    }\n}\n\nfn path_processor(leaf: Field, index: u32, hash_path: [Field; 10]) -> Field {\n    let mut calculated_hash = leaf;\n    let mut calculated_index = index;\n    for i in 0..10 {\n        calculated_hash = process_path_hash(calculated_hash, calculated_index, hash_path[i]);\n        calculated_index = calculated_index / 2;\n    }\n    calculated_hash\n}\n\n// H(asset_address, amount, H(secret,nonce))\nfn note_hasher(input: Note) -> Field {\n    let secret_hash =\n        poseidon::poseidon2::Poseidon2::hash([input.secret.secret, input.secret.nonce], 2);\n    poseidon::poseidon2::Poseidon2::hash(\n        [input.asset_address, input.amount as Field, secret_hash],\n        3,\n    )\n}\n\n// real note is\n// H(asset_address, amount, H(secret,nonce))\n// a UTXO note private use only\nstruct Note {\n    asset_address: Field,\n    amount: u128,\n    secret: Combined_secret,\n}\n// a UTXO note handling assets\nstruct Spending_asset {\n    asset_address: Field,\n    amount: u128,\n}\n\nstruct Merkle_proof {\n    index: u32,\n    path: [Field; 10],\n}\n\n// make order.\n// take in 2 notes\nfn main(\n    included_asset: pub [Field; 2],\n    merkle_root: pub Field,\n    order_hash: pub [Field; 3],\n    precomp_secret: pub [Field; 10],\n    order_asset: pub [Note; 2],\n    nullifier: pub [Field; 2],\n    new_note_hash: pub [Field; 2],\n    input_note: [Note; 2],\n    output_note: [Note; 2],\n    inclusion_proof: [Merkle_proof; 2],\n) {\n    // check if all input are valid\n    for i in 0..2 {\n        // skip if input note is empty\n        if input_note[i].amount != 0 {\n            // check correct nullifier\n            assert(nullifier[i] == input_note[i].secret.nonce);\n            // note is valid in tree\n            let leaf = note_hasher(input_note[i]);\n            let processed_root =\n                path_processor(leaf, inclusion_proof[i].index, inclusion_proof[i].path);\n            assert(processed_root == merkle_root);\n            // assert note asset is in included_asset in any order\n            assert(\n                (input_note[i].asset_address == included_asset[0])\n                    | (input_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    let mut sum_asset_1_in = 0u128;\n    let mut sum_asset_2_in = 0u128;\n    for i in 0..2 {\n        if input_note[i].asset_address == included_asset[0] {\n            sum_asset_1_in += input_note[i].amount;\n        } else {\n            sum_asset_2_in += input_note[i].amount;\n        }\n    }\n\n    // check if output notes are valid\n    for i in 0..2 {\n        if output_note[i].amount != 0 {\n            // note hash correctly\n            let out_hash = note_hasher(output_note[i]);\n            assert(new_note_hash[i] == out_hash);\n            // asset is in included_asset in any order\n            assert(\n                (output_note[i].asset_address == included_asset[0])\n                    | (output_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    // sum of output\n    let mut sum_asset_1_out = 0u128;\n    let mut sum_asset_2_out = 0u128;\n    for i in 0..2 {\n        if output_note[i].asset_address == included_asset[0] {\n            sum_asset_1_out += output_note[i].amount;\n        } else {\n            sum_asset_2_out += output_note[i].amount;\n        }\n    }\n\n    // sum order asset\n    for i in 0..2 {\n        if order_asset[i].amount != 0 {\n            // asset is in included_asset in any order\n            assert(\n                (order_asset[i].asset_address == included_asset[0])\n                    | (order_asset[i].asset_address == included_asset[1]),\n            );\n            if order_asset[i].asset_address == included_asset[0] {\n                sum_asset_1_out += order_asset[i].amount;\n            } else {\n                sum_asset_2_out += order_asset[i].amount;\n            }\n        }\n    }\n\n    // assert in and out\n    assert(sum_asset_1_in == sum_asset_1_out);\n    assert(sum_asset_2_in == sum_asset_2_out);\n}\n\nfn fake_merkle_proof(input: [Field; 2]) -> ([Merkle_proof; 2], Field) {\n    let mut current = leaf_hasher([input[0], input[1]]);\n    let mut p1 = [0; 10];\n    let mut p2 = [0; 10];\n    p1[0] = input[1];\n    p2[0] = input[0];\n\n    for i in 1..10 {\n        let random = poseidon::poseidon2::Poseidon2::hash([i as Field], 1);\n        current = leaf_hasher([current, random]);\n        p1[i] = random;\n        p2[i] = random;\n    }\n\n    let first_proof = Merkle_proof { index: 0, path: p1 };\n    let second_proof = Merkle_proof { index: 1, path: p2 };\n\n    ([first_proof, second_proof], current)\n}\n\n#[test]\nfn test_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p1.index, p1.path);\n    assert(root == root1);\n\n    let root2 = path_processor(test2, p2.index, p2.path);\n    assert(root2 == root);\n}\n\n#[test]\nfn test_failed_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p2.index, p1.path);\n    assert(root != root1);\n\n    let root2 = path_processor(test2, p1.index, p2.path);\n    assert(root2 != root);\n\n    let root3 = path_processor(test1, p1.index, p2.path);\n    assert(root != root3);\n\n    let root4 = path_processor(test1, p2.index, p1.path);\n    assert(root != root4);\n}\n\n#[test]\nfn test_simple_note_hash() {\n    let note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let hash = note_hasher(note);\n    assert(\n        hash\n            == poseidon::poseidon2::Poseidon2::hash(\n                [1, 100, poseidon::poseidon2::Poseidon2::hash([42, 69], 2)],\n                3,\n            ),\n    );\n}\n\n#[test]\nfn test_note_in_main() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note, empty_note],\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test]\nfn test_note_full() {\n    let test_note_1 =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let test_note_2 =\n        Note { asset_address: 2, amount: 50, secret: Combined_secret { secret: 123, nonce: 456 } };\n    let included_asset = [1, 2];\n\n    let test_note_1_hash = note_hasher(test_note_1);\n    let test_note_2_hash = note_hasher(test_note_2);\n\n    let new_note_1 =\n        Note { asset_address: 1, amount: 75, secret: Combined_secret { secret: 2, nonce: 3 } };\n\n    let new_note_2 =\n        Note { asset_address: 2, amount: 35, secret: Combined_secret { secret: 12, nonce: 31 } };\n\n    let new_note_hash_1 = note_hasher(new_note_1);\n    let new_note_hash_2 = note_hasher(new_note_2);\n\n    let tmp = fake_merkle_proof([test_note_1_hash, test_note_2_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n\n    let order_note_1 =\n        Note { asset_address: 2, amount: 15, secret: Combined_secret { secret: 0, nonce: 0 } };\n\n    let order_note_2 =\n        Note { asset_address: 1, amount: 25, secret: Combined_secret { secret: 0, nonce: 0 } };\n\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note_1, order_note_2],\n        [69, 456],\n        [new_note_hash_1, new_note_hash_2],\n        [test_note_1, test_note_2],\n        [new_note_1, new_note_2],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_sum() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note, order_note],\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_wrong_asset() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [3, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note, empty_note],\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n","path":"/Users/yoyoismacbook/Desktop/zinch/zeroinch/circuit/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/yoyoismacbook/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert","directive_integer_quotient"]}