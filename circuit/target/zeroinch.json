{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":18234218716811767871,"abi":{"parameters":[{"name":"included_asset","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"order_hash","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"precomp_secret","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"public"},{"name":"order_asset","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"public"},{"name":"nullifier","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"new_note_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"input_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"output_note","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Note","fields":[{"name":"asset_address","type":{"kind":"field"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret","type":{"kind":"struct","path":"Combined_secret","fields":[{"name":"secret","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}},"visibility":"private"},{"name":"inclusion_proof","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Merkle_proof","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"path","type":{"kind":"array","length":10,"type":{"kind":"field"}}}]}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dB5QVVdKufgzCkARhBBRUVBRU9DUzwIwBMeCuIEFkkwQZ0q4rWTcLjKCbJQi6WYKgm10ExLSrAsbdFQPBsEEUEHHNYmBR/yrp69y50/P+Pryv3um7zD2nTj+6h5qqul/d+323ByagfWNohmh7sO+zXBpE11ZsVc69kph7HWPudYq51znmXteYeyexHeXc6xXdK4r+HIVbY5h7faJrNr8RdsT5ytrxnq0Z8NkKfs+xfJVme5aVjevVfVxYGlZmu1eMLu+RLesxumd5WB72KO8xtnt5aem48rLyXhWjK3plK8Ky0nHh+B4VpeMjZ1p5n2MVGOT3k1gzjs98828XxYrK/cjIXwZc03bAnI8Ez0ld/ZNvnOd6Emff/Y+zu3tDYjuE9i2sJtYj2D6KPh9pfT7X+tw3+mz+3nlsn2H7LNv51n2tGvTb/xqUJqlBByvXjtbn86zP/Zwa9Ge7gG0A28DovliGqvszV02y+Y3wJNLBL2Hj7G7XYlB0HWwKYnZ8eXCkc28w1d75GygWcX9BOm78vjGIcIAfjMsxW0gWhYzbjvdCzYAvVPA7BAgGrbyHWAUG+Y1dXWWlNKtoN0q2w1zENpTtc2yfp2op4Pq2/fVP6PsLbF9k+xLbxY4/As7bOVGN0WwNia1hhN1FNNSI5NtAYW5QvpDzMRxYu3o2UmvUYCMjoutIUxDDPOSBy0ZGkl9sZAThQDmSsGykUKAcQf6B8pLoOoocAMoDF5SjSB+UCCAZUF5COFCOIiwoC0WRkXHb8VZqBlyp4Hc0EAxaeY+2CgzyG3vQmM1vhEKXgVQuFIo8nPCUeAxhwe/KAfFvaP/JlEwOjGUbxzae7ctUt9Sw/Y1J6PsrbJeyfZXtMtKVGqMVcIXs0QmE7SENqSH5pllqIOdjIrB29ayu1qjB6iZF18mmIIbByQOX1U0mv1jdJMKBcjJhWV2hQDmJ/APllOg6lRwAygMXlFNJH5QIIBlQTiEcKKcSFpSFkhrIuO14p2kGPE3B7+VAMGjlfblVYJBfFakhdBlI5UKhyBMJT4mvICz4XTkg/g3tP4WSyYGvsX2d7Rts36S6pYbt74qEvr/F9m2277BdSbpS43IFXCF7dDphe0hDaki+aZYayPmYAaxdPaurNWqwupnRtcoUxDA4eeCyuiryi9XNJBwoqwjL6goFypnkHyiviq6zyAGgPHBBOYv0QYkAkgHlVYQD5SzCgrJQUgMZtx3vbM2AZyv4vRoIBq28r7YKDPKrIjWELgOpXCgUeQbhKfE1hAW/KwfEv6H9WUomB77L9j2277P9gOqWGra/axL6/iHbj9h+zHYt6UqNqxVwhezROYTtIQ2pIfmmWWog52MusHb1rK7WqMHq5kXX+aYghsHJA5fVzSe/WN08woFyPmFZXaFAOY/8A+V10XUBOQCUBy4oF5A+KBFAMqC8jnCgXEBYUBZKaiDjtuNdqBnwQgW/1wPBoJX39VaBQX5VpIbQZSCVC4UizyU8Jb6BsOB35YD4N7Q/pGRy4CdsP2X7GdvPqW6pYfu7IaHvX7D9ku1XbDeSrtS4XgFXyB5dRNge0pAakm+apQZyPhYDa1fP6mqNGqxuSXRdagpiGJw8cFndUvKL1S0hHCiXEpbVFQqUS8g/UN4UXZeRA0B54IJyGemDEgEkA8qbCAfKZYQFZaGkBjJuO97lmgEvV/B7MxAMWnnfbBUY5FdFaghdBlK5UCjyYsJT4lsIC35XDoh/Q/u7UzI58Gu237D9lu13VLfUsP3dktD379n+wPZHtltJV2rcrIArZI/+ibA9pCE1JN80Sw3kfKwA1q6e1dUaNVjdbdF1pSmIYXDywGV1K8kvVncb4UC5krCsrlCgvI38A+Wq6LqaHADKAxeUq0kflAggGVCuIhwoVxMWlIWSGsi47Xhv1wz4dgW/a4Bg0Mp7jVVgkF8VqSF0GUjlQqHIKwhPie8gLPhdOSD+De0vpWRy4E62u9juZruH6pYatr87Evr+M9tf2O5lu490pcYaBVwhe/R+wvaQhtSQfNMsNZDzsRZYu3pWV2vUYHXrout6UxDD4OSBy+rWk1+sbh3hQLmesKyuUKBcR/6B8oHo+iA5AJQHLigfJH1QIoBkQPkA4UD5IGFBWSipgYzbjvchzYAfUvD7MBAMWnk/bBUY5FdFaghdBlK5UCjyWsJT4kcIC35XDoh/Q/vLKJkceJTtr2x/Y/s71S01bH+PJPT9GNsGtsfZniBdqfGwAq6QPfokYXtIQ2pIvmmWGsj5eApYu3pWV2vUYHUbo+smUxDD4OSBy+o2kV+sbiPhQLmJsKyuUKDcSP6BcnN03UIOAOWBC8otpA9KBJAMKDcTDpRbCAvKQkkNZNx2vE9rBvy0gt9ngGDQyvsZq8AgvypSQ+gykMqFQpGfIjwlfpaw4HflgPg3tL8HJZMDz7H9g+2fbP+iuqWG7e/ZhL7/zfY821a2F0hXajyjgCtkj75I2B7SkBqSb5qlBnI+tgFrV8/qao0arG57dN1hCmIYnDxwWd0O8ovVbSccKHcQltUVCpTbyT9QvhRdd5IDQHnggnIn6YMSASQDypcIB8qdhAVloaQGMm473pc1A35Zwe8uIBi08t5lFRjkV0VqCF0GUrlQKPI2wlPiVwgLflcOiH9D+3tSMjnwH7ZX2V5je53qlhq2v1cS+n6D7U22t9jeJl2psUsBV8gefYewPaQhNSTfNEsN5HzsBtaOFLAnfQnETCi9uFuh994lLK7NyKQYh+8pYyff+MQfMsZ3I3+ExXiN+UavO8A4ww7AuN4H1q+QxB0Ztx3vB5oBf6Dgdw8YpBp577EKDPKr2qwBpbNZ/0t+NisybjvevZoB71Xw+yGlu1kl7w+tAoP8xsaab/57oljRR2x7UjrfHynPRza/EQoj+0hhnoHMsaCLXifSWfQ+1gz4YwW/4hAFBq28bUSA/MYeLeabf/soVlTux0T+0McF7YE5H0PYRnKPEo+m6oXrGEp2lBhIzdgasBUFdR9THmX56GR9lr9vPvdzfDfkmwexNWJrHPku5Iu6XoTtAXeAfNd4UVccFaGJWd3NSzl54L6oky/SflFnFzHfF3XFwAW0SeDnboqM2463aaAYcNMA77dZyndTybuZwm4at7o2tFbRckq2cjfnmy3YDmZrmWPltv3Z3yeX71Z88xC21mxtAr0XTBTVGL1rI7FVEmB3EQ1WKvnCD3qBNUTOx6FA1ljPRmqNGmykbVSEdi4baRvDRtp5xkbaAkHZDsxGCgXKtoF/oGwfFeEwF5TtY0B5WAFAiQCSAWV7ICgP85QiI+O24z08UAz4cAWK3CHlFFny7qBAkcUHmhIKXQZSuVAo8qEBnhJ3BIPflQMdLQlQQcnkwBGysLIdxdYph9Sw/XVMKDWO5pvHsB3L1jnQlRodFKQGskeP80BqdEi51EDOx/GeSg0fWV2XqAhdXVbXJYbVdfWM1XUBgrKrp1Kji4egPCEqwokuKE+IAeWJBQBlFyAoTwCC8kRPpQYybjvekwLFgE9SkBrdUi41JO9unkgNoctAKhcKRT5eQWqcrCw1TrYkwKmUTA6cwjfFWcjWPYfUsP2dnFBqlPLNMrYebD0DXanRTUFqIHu0lwdSo1vKpQZyPso9lRo+srqKqAinuqyuIobVneoZq6sAgvJUT6VGhYegPC0qwukuKE+LAeXpBQBlBRCUpwFBebqnUgMZtx3vGYFiwGcoSI3eKZcakndvT6SG0GUglQuFIpcrSI0zlaXGmZYEOI2SyYE+fPMstrPZzskhNWx/ZyaUGufyzb5s57F9JtCVGr0VpAayRz/rgdTonXKpgZyP8z2VGj6yun5REfq7rK5fDKvr7xmr6wcEZX9PpUY/D0F5QVSEAS4oL4gB5YACgLIfEJQXAEE5wFOpgYzbjndgoBjwQAWpMSjlUkPyHuSJ1BC6DKRyoVDk8xWkxmBlqTHYkgCnUzI5cCHfHMJ2EdvQHFLD9jc4odT4HN/8PNsX2L4Y6EqNQQpSA9mjX/JAagxKudRAzsfFnkoNH1ndsKgIw11WNyyG1Q33jNUNA4JyuKdSY5iHoBwRFWGkC8oRMaAcWQBQDgOCcgQQlCM9lRrIuO14LwkUA75EQWqMSrnUkLxHeSI1hC4DqVwoFPliBalRqSw1Ki0JcAYlkwOj+eYYtrFs43JIDdtfZUKpMZ5vfpntK2yXBrpSY5SC1ED26Fc9kBqjUi41kPNxmadSw0dWNyEqwkSX1U2IYXUTPWN1E4CgnOip1JjgISgnRUWY7IJyUgwoJxcAlBOAoJwEBOVkT6UGMm473imBYsBTFKTG1JRLDcl7qidSQ+gykMqFQpEvU5Aa05SlxjRLAvSmZHLgcr55BdvX2L6eQ2rY/qYllBrf4JvfZPsW27cDXakxVUFqIHv0Ox5IjakplxrI+bjSU6nhI6ubHhVhhsvqpsewuhmesbrpQFDO8FRqTPcQlDOjIlS5oJwZA8qqAoByOhCUM4GgrPJUaiDjtuO9KlAM+CoFqTEr5VJD8p7lidQQugykcqFQ5CsVpMZsZakx25IAZ1IyOXA137yG7bts38shNWx/sxNKje/zzR+w/ZDtR4Gu1JilIDWQPfpjD6TGrJRLDeR8XOup1PCR1c2JijDXZXVzYljdXM9Y3RwgKOd6KjXmeAjKeVER5rugnBcDyvkFAOUcICjnAUE531OpgYzbjve6QDHg6xSkxoKUSw3Je4EnUkPoMpDKhUKRr1WQGguVpcZCSwLI90kiB67nmzew/YTtpzmkhu1vYUKp8TO++XO2X7D9MtCVGgsUpAayR3/lgdRYkHKpgZyPGz2VGj6yukVRERa7rG5RDKtb7BmrWwQE5WJPpcYiD0G5JCrCUheUS2JAubQAoFwEBOUSICiXeio1kHHb8d4UKAZ8k4LUWJZyqSF5L/NEaghdBlK5UCjyjQpSY7my1FhuSYCzKJkcuJlv3sL2a7bf5JAatr/lCaXGb/nm79h+z/aHQFdqLFOQGsge/aMHUmNZyqUGcj5uBa4X4gONPelLIGZC6cVbFda0PymxzEyKcbhCGTv5xif+kDHKHK9Q4gJmwNcdYC8eBYzrNk+JOzJuO96VgWLAKxWI+6qUE3fJe5VnzRpQOpt1tafNulqpWW8PFAO+XaFZ16S8WSXvNUrNimZ6q6JY0Udsq4J0zvcdKVdswsjuUGD0K4J6hpdPXHd6umncqbRp3BUoBnyXwqZxd8o3Dcn77gJtGtn8RtiRfewh/PFIJ8LN0T0pX+hlru9RWOj/DG54815O/FZRzYE+4kD26F/AxzlaPYSe/3uVcZ/3ryGP8kYTzo6UznXovpSvQ9In9ymsQ/crrUP3W+uQFjbR+1pHYIxrPSWinQmLBzPWBYoBr1MgoutTTkQl7/UKRFRcuu+fj6Pq98zHU7L3zw/wzQfZHmJ7OKj73faxlo/O1mf5++ZzP8f3I3zzUba/sv0t8m2eZaju0QdUe9snel4fUTgBCOoKNl9grweyt/+VCTyMDtAJtCcPFZ8UExmj+JIOQ1OHw4A5a6wAMtJ8BngsMK6/e0q9kHHb8T4WKAb8mAL12pBy6iV5b1A6AzQjzW95kc36uKfN+rhSsz4RKAb8hEKzPpnyZpW8nyzQgX2++W+IYkUfum0I0jnfTykxHTQLRZ4FbEz5gbfMyUaFg8aNni70XUlnod8UKAa8SWGh35zyhV7y3lygA7ETqPpw6kRKdiC2hW8+zfYM27M5DsS6WD66Wp+35DgQe45v/oPtn2z/+h87EHvOpwOxzfUHYrV8H04H6ATak4eKT4qJjFF8PadwIHY4MGeNFUBGmg/EugDj+ren1AsZtx3v84FiwM8rUK+tKadekvfWA/hADNmsL3jarC8oNeuLgWLALyo067aUN6vkvc2TA7GtUazoA7GtQTrne7snB2LIs4AdKT8QkznZoXAgtiPwY6NE1hK5Ub7k6Ub5ktJGuTNQDHinwkb5cso3Ssn75QJtlNn8xic/DbhBQcbbp9/5ztGuIN01lLnepbDQvwJuePMj1uK3imoO9EaP7NH/pHyjNz2Env9XlXGfb3wmbzTJBv4oOXQdei3l65D0yWsKOHxdaR16PdD7px5a+1pnYIxveEpEWxEWD2a8GSgG/KYCEX0r5URU8n7Ls+NVZP4tgXG97Wmzvh3oNOs7gWLA7yg06+6UN6vkvfsAfheCbNZ3PW3Wd5Wa9b1AMeD3FJr1/ZQ3q+T9vifvQnZHsaJl2u4gnfP9gdL5OPqIBMke96T8iETmZI+CNN0T6PZeNr+hdjQ4IJP+o4hXFfIemNHp7SJw/q2AOf8X2NtA3IQDU47B3Uprzt6UrzmCl70KeX+odAz4YQFeR+wF7rUfgfdaM9Di7OP6dWO/4pM9+w2F/hnkwZ6t8fpg8AG4ZxOwX4C4CQcrYxChVfcovLbZA1z/g5T3sRRPYkTPTSajs/+L3yqqOdD7vz1n+fpqkPFj/y86ANagQh7OlhAW/2Y0zCgG3DCD93sQsJm08j4oU11gkF9vXnu2AcbVyNNmbZTRadbGGcWAGys0a3HKm1XyLvasWZGvPZHN2sTTZm2i1KxNM4oBN1Vo1mYpb1bJu5lSs6LlSnEUK/q1Z3EmnfPdXOmYBS3FkOyxBViKoftF5qSFghRvkdHtvWx+Q+0VxIUpz1teDXyskPcQT45QS4A5HwzsbSBuwiEpx2Cx0prTMuV5C15aKuTdSunYs1UBjj1bAvfaQ8B7rRlocda6ft3Yr/i0XhtclPK85Ti/SCHvoQfgnt0G2C9A3IRDlTGI0KqyZ2fAc9sCuP6XpLyPBXslCn18qNL+f2gB9v8S4Py39WT/b3eArEHofcD8wkqUP/nFc/cCf+zC8HuUP+GzrTPVOEz73KwFz819AXbfR6817RTmJrDm5rjo2oFNfoHfEWxHsh3F1ontaLZjaN/vGescfb38DjP5r4jkfxWQ/8pZ/gvnk9i6sZ3MdorEyCYLXHepA1sZWw+2nmy92MrZKthOZTuN7XS2M9h6s50Z5XpWFJcZn/yYDO1bKyX+hmwHsTVia8xWzNaErSlbM7bmbC3YDmaTf1cnP9om/110azZ54SSc71C2tmzt2NqzyW8iOtz6no2tzxOjTbVk21ntpz56S1/rEU3L8WxxjmfLczy7K8eztTmePZ3j2fN1PDP7T7/oWhxdDfzMnt0n+nM2vxEWW37R/suzZT2LqeYAx19abPlU8N/d+C/S8Z9tFPk5t6qmf3K+bwPn69y/I6M51X5Jar7GPLOWMeobPZPeakHVnw+OPhc7/jSwYceErm3rmPjN92oa5Xquk6tde9yL9Z5j4nCE819aafw31Im/wvg/SMV/r9HGfyMd/2ON/8Y69fkUy8U6/scZ/01U/Hf/dJ1rqhN/D+O/mY7/MuO/uY7/0Wb9NOuk+R5E1WvHwdZ93DoWhoHz/YhqrlPkfP8mTqxozhA438/E49bHrLWmdi1jYm0Z88xdY1rGfJ+WMd8nzlcToK/mQF8Ngb6Kgb6aAX0ha1+U0rgaA30hMdEU6KsB0Fda8WV4RxwPlNEnumbzHCbWophY49ZOqZfBxZRpl066gpxhOwqsgM2fM86zIqsI9tc1qMMf/T/+gxhfMgSAZmEqqqr5ffpE97N5jF7l1T9d2SDy35Cq87BHkfXc/vrzoz/bQDLXojziHN+rMhxfWjm+skfl2LFlYyoPcfzLyMTUyVxLCF+vrCX22+j4/1TM2qPE+tzGydMWo31AMRh/BgcNqfbIOM/M1zZ24gvw8YVuLA1ivpcZraNrG+teSR2x2hhGH4DIaKrjPxYzTazPTZ1nZu6KYv5eUMefM84119cGOfw2j3lmfJq5suM1efwfZJsa/7enAQA=","debug_symbols":"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","file_map":{"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"use dep::poseidon;\nuse trees::merkle::MerkleTree;\n\nstruct Combined_secret {\n    secret: Field,\n    nonce: Field,\n}\n\nfn leaf_hasher(leafs: [Field; 2]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(leafs, 2)\n}\n\nfn process_path_hash(leaf: Field, index: u32, another_leaf: Field) -> Field {\n    // if index is even, then leaf is left child\n    // if index is odd, then leaf is right child\n    if index % 2 == 0 {\n        leaf_hasher([leaf, another_leaf])\n    } else {\n        leaf_hasher([another_leaf, leaf])\n    }\n}\n\nfn path_processor(leaf: Field, index: u32, hash_path: [Field; 10]) -> Field {\n    let mut calculated_hash = leaf;\n    let mut calculated_index = index;\n    for i in 0..10 {\n        calculated_hash = process_path_hash(calculated_hash, calculated_index, hash_path[i]);\n        calculated_index = calculated_index / 2;\n    }\n    calculated_hash\n}\n\n// H(asset_address, amount, H(secret,nonce))\nfn note_hasher(input: Note) -> Field {\n    let secret_hash =\n        poseidon::poseidon2::Poseidon2::hash([input.secret.secret, input.secret.nonce], 2);\n    poseidon::poseidon2::Poseidon2::hash(\n        [input.asset_address, input.amount as Field, secret_hash],\n        3,\n    )\n}\n\n// real note is\n// H(asset_address, amount, H(secret,nonce))\n// a UTXO note private use only\nstruct Note {\n    asset_address: Field,\n    amount: u128,\n    secret: Combined_secret,\n}\n// a UTXO note handling assets\nstruct Spending_asset {\n    asset_address: Field,\n    amount: u128,\n}\n\nstruct Merkle_proof {\n    index: u32,\n    path: [Field; 10],\n}\n\n// make order.\n// take in 2 notes\nfn main(\n    included_asset: pub [Field; 2],\n    merkle_root: pub Field,\n    order_hash: pub [Field; 3],\n    precomp_secret: pub [Field; 10],\n    order_asset: pub [Note; 2],\n    nullifier: pub [Field; 2],\n    new_note_hash: pub [Field; 2],\n    input_note: [Note; 2],\n    output_note: [Note; 2],\n    inclusion_proof: [Merkle_proof; 2],\n) {\n    // check if all input are valid\n    for i in 0..2 {\n        // skip if input note is empty\n        if input_note[i].amount != 0 {\n            // check correct nullifier\n            assert(nullifier[i] == input_note[i].secret.nonce);\n            // note is valid in tree\n            let leaf = note_hasher(input_note[i]);\n            let processed_root =\n                path_processor(leaf, inclusion_proof[i].index, inclusion_proof[i].path);\n            assert(processed_root == merkle_root);\n            // assert note asset is in included_asset in any order\n            assert(\n                (input_note[i].asset_address == included_asset[0])\n                    | (input_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    let mut sum_asset_1_in = 0;\n    let mut sum_asset_2_in = 0;\n    for i in 0..2 {\n        if input_note[i].asset_address == included_asset[0] {\n            sum_asset_1_in += input_note[i].amount;\n        } else {\n            sum_asset_2_in += input_note[i].amount;\n        }\n    }\n\n    // check if output notes are valid\n    for i in 0..2 {\n        if output_note[i].amount != 0 {\n            // note hash correctly\n            let out_hash = note_hasher(output_note[i]);\n            println(out_hash);\n            println(new_note_hash[i]);\n\n            assert(new_note_hash[i] == out_hash);\n            // asset is in included_asset in any order\n            assert(\n                (output_note[i].asset_address == included_asset[0])\n                    | (output_note[i].asset_address == included_asset[1]),\n            );\n        }\n    }\n\n    // sum of output\n    let mut sum_asset_1_out = 0;\n    let mut sum_asset_2_out = 0;\n    for i in 0..2 {\n        if output_note[i].asset_address == included_asset[0] {\n            sum_asset_1_out += output_note[i].amount;\n        } else {\n            sum_asset_2_out += output_note[i].amount;\n        }\n    }\n\n    // sum order asset\n    for i in 0..2 {\n        if order_asset[i].amount != 0 {\n            // asset is in included_asset in any order\n            assert(\n                (order_asset[i].asset_address == included_asset[0])\n                    | (order_asset[i].asset_address == included_asset[1]),\n            );\n            if order_asset[i].asset_address == included_asset[0] {\n                sum_asset_1_out += order_asset[i].amount;\n            } else {\n                sum_asset_2_out += order_asset[i].amount;\n            }\n        }\n    }\n\n    // assert in and out\n    assert(sum_asset_1_in == sum_asset_1_out);\n    assert(sum_asset_2_in == sum_asset_2_out);\n}\n\nfn fake_merkle_proof(input: [Field; 2]) -> ([Merkle_proof; 2], Field) {\n    let mut current = leaf_hasher([input[0], input[1]]);\n    let mut p1 = [0; 10];\n    let mut p2 = [0; 10];\n    p1[0] = input[1];\n    p2[0] = input[0];\n\n    for i in 1..10 {\n        let random = poseidon::poseidon2::Poseidon2::hash([i as Field], 1);\n        current = leaf_hasher([current, random]);\n        p1[i] = random;\n        p2[i] = random;\n    }\n\n    let first_proof = Merkle_proof { index: 0, path: p1 };\n    let second_proof = Merkle_proof { index: 1, path: p2 };\n\n    ([first_proof, second_proof], current)\n}\n\n#[test]\nfn test_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p1.index, p1.path);\n    assert(root == root1);\n\n    let root2 = path_processor(test2, p2.index, p2.path);\n    assert(root2 == root);\n}\n\n#[test]\nfn test_failed_tree() {\n    let test1 = 69;\n    let test2 = 420;\n\n    let tmp = fake_merkle_proof([test1, test2]);\n    let p1 = tmp.0[0];\n    let p2 = tmp.0[1];\n    let root = tmp.1;\n\n    let root1 = path_processor(test1, p2.index, p1.path);\n    assert(root != root1);\n\n    let root2 = path_processor(test2, p1.index, p2.path);\n    assert(root2 != root);\n\n    let root3 = path_processor(test1, p1.index, p2.path);\n    assert(root != root3);\n\n    let root4 = path_processor(test1, p2.index, p1.path);\n    assert(root != root4);\n}\n\n#[test]\nfn test_simple_note_hash() {\n    let note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let hash = note_hasher(note);\n    assert(\n        hash\n            == poseidon::poseidon2::Poseidon2::hash(\n                [1, 100, poseidon::poseidon2::Poseidon2::hash([42, 69], 2)],\n                3,\n            ),\n    );\n}\n\n#[test]\nfn test_note_in_main() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note, empty_note],\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test]\nfn test_note_full() {\n    let test_note_1 =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let test_note_2 =\n        Note { asset_address: 2, amount: 50, secret: Combined_secret { secret: 123, nonce: 456 } };\n    let included_asset = [1, 2];\n\n    let test_note_1_hash = note_hasher(test_note_1);\n    let test_note_2_hash = note_hasher(test_note_2);\n\n    let new_note_1 =\n        Note { asset_address: 1, amount: 75, secret: Combined_secret { secret: 2, nonce: 3 } };\n\n    let new_note_2 =\n        Note { asset_address: 2, amount: 35, secret: Combined_secret { secret: 12, nonce: 31 } };\n\n    let new_note_hash_1 = note_hasher(new_note_1);\n    let new_note_hash_2 = note_hasher(new_note_2);\n\n    let tmp = fake_merkle_proof([test_note_1_hash, test_note_2_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n\n    let order_note_1 =\n        Note { asset_address: 2, amount: 15, secret: Combined_secret { secret: 0, nonce: 0 } };\n\n    let order_note_2 =\n        Note { asset_address: 1, amount: 25, secret: Combined_secret { secret: 0, nonce: 0 } };\n    println([new_note_hash_1, new_note_hash_2]);\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note_1, order_note_2],\n        [69, 456],\n        [new_note_hash_1, new_note_hash_2],\n        [test_note_1, test_note_2],\n        [new_note_1, new_note_2],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_sum() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [1, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note, order_note],\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n\n#[test(should_fail)]\nfn test_note_in_fail_wrong_asset() {\n    let test_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 42, nonce: 69 } };\n    let included_asset = [3, 2];\n    let note_hash = note_hasher(test_note);\n    let tmp = fake_merkle_proof([note_hash, note_hash]);\n    let inclusion_proof = tmp.0;\n    let merkle_root = tmp.1;\n    let empty_note =\n        Note { asset_address: 0, amount: 0, secret: Combined_secret { secret: 0, nonce: 0 } };\n    let order_note =\n        Note { asset_address: 1, amount: 100, secret: Combined_secret { secret: 0, nonce: 0 } };\n    // too many order\n    main(\n        included_asset,\n        merkle_root,\n        [0, 0, 0],\n        [0; 10],\n        [order_note, empty_note],\n        [69, 0],\n        [note_hash, note_hash],\n        [test_note, empty_note],\n        [empty_note, empty_note],\n        inclusion_proof,\n    );\n}\n","path":"/Users/yoyoismacbook/Desktop/zinch/zeroinch/circuit/src/main.nr"},"68":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/yoyoismacbook/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["print_unconstrained","directive_invert","directive_integer_quotient"]}